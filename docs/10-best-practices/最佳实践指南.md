# 最佳实践指南

## 一、工作流设计最佳实践

### 1.1 工作流粒度设计

**原则**：工作流应该是业务逻辑的完整单元

✅ **好的设计**：

```go
// 完整的订单处理工作流
func OrderProcessingWorkflow(ctx workflow.Context, order Order) error {
    // 1. 验证订单
    err := workflow.ExecuteActivity(ctx, ValidateOrder, order).Get(ctx, nil)

    // 2. 处理支付
    err = workflow.ExecuteActivity(ctx, ProcessPayment, order).Get(ctx, nil)

    // 3. 发货
    err = workflow.ExecuteActivity(ctx, ShipOrder, order).Get(ctx, nil)

    return err
}
```

❌ **不好的设计**：

```go
// 工作流粒度过细
func ValidateOrderWorkflow(ctx workflow.Context, order Order) error {
    return workflow.ExecuteActivity(ctx, ValidateOrder, order).Get(ctx, nil)
}
```

### 1.2 Activity设计原则

**原则1：保持幂等性**:

```go
func ProcessPayment(ctx context.Context, payment Payment) error {
    // 使用幂等键确保幂等性
    idempotencyKey := fmt.Sprintf("payment-%s-%d", payment.OrderID, payment.Amount)

    // 检查是否已处理
    if exists, _ := checkIfProcessed(idempotencyKey); exists {
        return nil // 已处理，直接返回
    }

    // 处理支付
    result := executePayment(payment)

    // 记录处理结果
    recordProcessing(idempotencyKey, result)

    return nil
}
```

**原则2：合理设置超时**:

```go
ao := workflow.ActivityOptions{
    StartToCloseTimeout:    10 * time.Minute,  // 总超时时间
    ScheduleToCloseTimeout: 15 * time.Minute,  // 包含调度时间
    HeartbeatTimeout:       1 * time.Minute,   // 心跳超时
    RetryPolicy: &temporal.RetryPolicy{
        InitialInterval:    time.Second,
        BackoffCoefficient: 2.0,
        MaximumInterval:    time.Minute,
        MaximumAttempts:    3,
    },
}
```

**原则3：使用心跳机制**:

```go
func LongRunningActivity(ctx context.Context, data Data) error {
    for i := 0; i < 100; i++ {
        // 执行处理
        processChunk(data, i)

        // 发送心跳
        activity.RecordHeartbeat(ctx, fmt.Sprintf("Progress: %d%%", i))

        // 检查取消
        if ctx.Err() != nil {
            return ctx.Err()
        }
    }
    return nil
}
```

### 1.3 错误处理最佳实践

**1. 使用Saga模式处理分布式事务**:

```go
func SagaWorkflow(ctx workflow.Context, order Order) error {
    var compensationStack []Compensation

    // 步骤1：锁定库存
    err := workflow.ExecuteActivity(ctx, LockInventory, order).Get(ctx, nil)
    if err != nil {
        return err
    }
    compensationStack = append(compensationStack, UnlockInventory)

    // 步骤2：处理支付
    err = workflow.ExecuteActivity(ctx, ProcessPayment, order).Get(ctx, nil)
    if err != nil {
        // 补偿：解锁库存
        workflow.ExecuteActivity(ctx, UnlockInventory, order).Get(ctx, nil)
        return err
    }
    compensationStack = append(compensationStack, RefundPayment)

    // 步骤3：发货
    err = workflow.ExecuteActivity(ctx, ShipOrder, order).Get(ctx, nil)
    if err != nil {
        // 补偿：退款和解锁库存
        workflow.ExecuteActivity(ctx, RefundPayment, order).Get(ctx, nil)
        workflow.ExecuteActivity(ctx, UnlockInventory, order).Get(ctx, nil)
        return err
    }

    return nil
}
```

**2. 使用选择器处理超时**:

```go
func WorkflowWithTimeout(ctx workflow.Context) error {
    selector := workflow.NewSelector(ctx)

    // 添加Activity
    future := workflow.ExecuteActivity(ctx, LongRunningActivity)
    selector.AddFuture(future, func(f workflow.Future) {
        // Activity完成处理
    })

    // 添加超时
    timeoutFuture := workflow.NewTimer(ctx, 5*time.Minute)
    selector.AddFuture(timeoutFuture, func(f workflow.Future) {
        // 超时处理
        workflow.ExecuteActivity(ctx, HandleTimeout).Get(ctx, nil)
    })

    selector.Select(ctx)
    return nil
}
```

## 二、性能优化最佳实践

### 2.1 并行执行

**原则**：尽可能并行执行独立的Activity

```go
func ParallelWorkflow(ctx workflow.Context, data Data) error {
    // 并行执行多个Activity
    future1 := workflow.ExecuteActivity(ctx, ProcessA, data)
    future2 := workflow.ExecuteActivity(ctx, ProcessB, data)
    future3 := workflow.ExecuteActivity(ctx, ProcessC, data)

    // 等待所有完成
    var result1, result2, result3 Result
    err1 := future1.Get(ctx, &result1)
    err2 := future2.Get(ctx, &result2)
    err3 := future3.Get(ctx, &result3)

    if err1 != nil || err2 != nil || err3 != nil {
        return fmt.Errorf("parallel execution failed")
    }

    // 合并结果
    return workflow.ExecuteActivity(ctx, MergeResults, result1, result2, result3).Get(ctx, nil)
}
```

### 2.2 批量处理

**原则**：使用批量处理减少数据库操作

```go
func BatchProcessingWorkflow(ctx workflow.Context, items []Item) error {
    batchSize := 100

    for i := 0; i < len(items); i += batchSize {
        end := i + batchSize
        if end > len(items) {
            end = len(items)
        }

        batch := items[i:end]
        err := workflow.ExecuteActivity(ctx, ProcessBatch, batch).Get(ctx, nil)
        if err != nil {
            return err
        }
    }

    return nil
}
```

### 2.3 缓存策略

**原则**：缓存频繁访问的数据

```go
func CachedWorkflow(ctx workflow.Context, key string) (Result, error) {
    // 检查缓存
    cached, err := workflow.ExecuteActivity(ctx, GetFromCache, key).Get(ctx, nil)
    if err == nil && cached != nil {
        return cached, nil
    }

    // 缓存未命中，从数据库获取
    result, err := workflow.ExecuteActivity(ctx, GetFromDatabase, key).Get(ctx, nil)
    if err != nil {
        return nil, err
    }

    // 更新缓存
    workflow.ExecuteActivity(ctx, UpdateCache, key, result).Get(ctx, nil)

    return result, nil
}
```

## 三、存储优化最佳实践

### 3.1 PostgreSQL配置优化

**1. 连接池配置**:

```yaml
persistence:
  postgres:
    maxConns: 500
    maxIdleConns: 50
    connMaxLifetime: 1h
    connMaxIdleTime: 10m
```

**2. 索引策略**:

```sql
-- 高选择性索引
CREATE INDEX idx_workflow_id ON executions(workflow_id) WHERE status = 'Running';

-- 复合索引
CREATE INDEX idx_workflow_status_time ON executions(
    namespace_id,
    workflow_type,
    status,
    start_time DESC
) WHERE status = 'Running';

-- 分区表
CREATE TABLE history_events (
    workflow_id uuid,
    event_id bigint,
    event_data jsonb,
    created_at timestamptz
) PARTITION BY RANGE (created_at);
```

**3. 查询优化**:

```sql
-- 使用EXPLAIN ANALYZE分析查询
EXPLAIN ANALYZE
SELECT * FROM executions
WHERE status = 'Running' AND start_time > NOW() - INTERVAL '1 hour';

-- 使用覆盖索引
CREATE INDEX idx_covering ON executions(
    namespace_id,
    workflow_type,
    status
) INCLUDE (run_id, execution_time);
```

### 3.2 数据归档策略

**原则**：定期归档历史数据

```sql
-- 创建归档表
CREATE TABLE history_events_archive (LIKE history_events INCLUDING ALL);

-- 归档旧数据
INSERT INTO history_events_archive
SELECT * FROM history_events
WHERE created_at < NOW() - INTERVAL '90 days';

-- 删除已归档数据
DELETE FROM history_events
WHERE created_at < NOW() - INTERVAL '90 days';
```

## 四、监控和告警最佳实践

### 4.1 关键指标监控

**1. 性能指标**:

```yaml
metrics:
  - name: workflow_throughput
    type: counter
    description: "工作流吞吐量 (workflows/s)"

  - name: activity_latency
    type: histogram
    description: "Activity延迟分布"
    buckets: [0.1, 0.5, 1, 5, 10, 30, 60]

  - name: workflow_failure_rate
    type: gauge
    description: "工作流失败率"
```

**2. 资源指标**:

```yaml
metrics:
  - name: db_connections
    type: gauge
    description: "数据库连接数"

  - name: db_query_latency
    type: histogram
    description: "数据库查询延迟"

  - name: worker_cpu_usage
    type: gauge
    description: "Worker CPU使用率"
```

### 4.2 告警规则

**1. 性能告警**:

```yaml
alerts:
  - name: high_latency
    condition: activity_latency_p99 > 1000ms
    severity: warning
    action: notify_team

  - name: low_throughput
    condition: workflow_throughput < 10 workflows/s
    severity: critical
    action: page_oncall
```

**2. 错误告警**:

```yaml
alerts:
  - name: high_failure_rate
    condition: workflow_failure_rate > 5%
    severity: critical
    action: page_oncall

  - name: db_connection_exhausted
    condition: db_connections > 450
    severity: warning
    action: notify_team
```

## 五、安全最佳实践

### 5.1 数据加密

**1. 传输加密**:

```go
// 使用TLS加密连接
config := client.Options{
    HostPort:  "temporal.example.com:7233",
    Namespace: "default",
    TLS: &tls.Config{
        ServerName: "temporal.example.com",
    },
}
```

**2. 存储加密**:

```sql
-- PostgreSQL加密
CREATE TABLE sensitive_data (
    id uuid PRIMARY KEY,
    encrypted_data bytea
);

-- 使用pgcrypto扩展
CREATE EXTENSION IF NOT EXISTS pgcrypto;
```

### 5.2 访问控制

**1. 命名空间隔离**:

```go
// 不同环境使用不同命名空间
config := client.Options{
    Namespace: "production", // 或 "staging", "development"
}
```

**2. 权限控制**:

```yaml
# Temporal权限配置
authorization:
  - namespace: production
    permissions:
      - user: admin
        actions: [read, write, delete]
      - user: developer
        actions: [read, write]
```

## 六、测试最佳实践

### 6.1 单元测试

```go
func TestWorkflow(t *testing.T) {
    testSuite := &tests.WorkflowTestSuite{}
    env := testSuite.NewTestWorkflowEnvironment()

    // 模拟Activity
    env.OnActivity(ProcessPayment, mock.Anything, mock.Anything).
        Return(nil)

    // 执行工作流
    env.ExecuteWorkflow(OrderProcessingWorkflow, Order{})

    // 验证结果
    require.True(t, env.IsWorkflowCompleted())
    require.NoError(t, env.GetWorkflowError())
}
```

### 6.2 集成测试

```go
func TestIntegration(t *testing.T) {
    // 启动测试环境
    testEnv := startTestEnvironment(t)
    defer testEnv.Stop()

    // 创建客户端
    client := testEnv.GetClient()

    // 启动工作流
    workflowID := "test-workflow"
    run, err := client.ExecuteWorkflow(
        context.Background(),
        client.StartWorkflowOptions{ID: workflowID},
        OrderProcessingWorkflow,
        Order{},
    )
    require.NoError(t, err)

    // 等待完成
    var result Result
    err = run.Get(context.Background(), &result)
    require.NoError(t, err)
}
```

## 七、版本管理最佳实践

### 7.1 工作流版本控制

```go
// 使用版本标记
func WorkflowV2(ctx workflow.Context, input Input) error {
    // 检查版本
    version := workflow.GetVersion(ctx, "workflow-version", workflow.DefaultVersion, 2)

    if version == workflow.DefaultVersion {
        // 旧版本逻辑
        return oldWorkflowLogic(ctx, input)
    } else {
        // 新版本逻辑
        return newWorkflowLogic(ctx, input)
    }
}
```

### 7.2 向后兼容

**原则**：新版本必须兼容旧版本

```go
func CompatibleWorkflow(ctx workflow.Context, input Input) error {
    // 支持新旧两种输入格式
    var data Data
    if input.Version == "v1" {
        data = convertV1ToV2(input)
    } else {
        data = input.Data
    }

    return processData(ctx, data)
}
```

## 八、总结

### 8.1 核心原则

1. **幂等性**：所有Activity必须幂等
2. **超时控制**：合理设置超时时间
3. **错误处理**：使用Saga模式处理分布式事务
4. **性能优化**：并行执行、批量处理、缓存策略
5. **监控告警**：建立完善的监控和告警体系
6. **安全控制**：数据加密、访问控制
7. **测试覆盖**：单元测试、集成测试
8. **版本管理**：向后兼容、平滑升级

### 8.2 检查清单

- [ ] 工作流粒度设计合理
- [ ] Activity具有幂等性
- [ ] 超时时间配置合理
- [ ] 错误处理完善
- [ ] 性能优化到位
- [ ] 监控告警配置
- [ ] 安全措施到位
- [ ] 测试覆盖充分
- [ ] 版本管理规范

---

**最佳实践指南版本**：1.0

**最后更新**：2024年

**维护者**：项目团队
