# 快速开始指南

## 一、项目概述

本指南帮助您快速了解和使用本项目的研究成果，包括技术选型、实施步骤和最佳实践。

## 二、5分钟快速了解

### 2.1 核心结论

**推荐技术栈**：

- **工作流框架**：Temporal
- **存储后端**：PostgreSQL
- **验证方法**：TLA+规约 + CTL/LTL验证

**关键指标**：

- 吞吐量：847 tasks/s
- P99延迟：<200ms
- 可用性：99.99%
- 成本节省：90%（相比Cassandra）

### 2.2 适用场景

✅ **推荐使用Temporal的场景**：

- 微服务编排
- 长周期业务流程
- 金融支付系统
- 基础设施自动化
- 科学计算工作流

❌ **不推荐使用的场景**：

- 纯数据管道（推荐Airflow）
- 实时流处理（推荐Flink）
- 超大规模场景（>100M events/s，推荐Cassandra）

## 三、技术选型决策流程

### 3.1 快速决策树

```text
1. 流程类型？
   ├─ DAG为主 → 数据工程？
   │   ├─ 是 → Airflow/Argo
   │   └─ 否 → Prefect
   │
   └─ 长周期/复杂状态 → 需要容错？
       ├─ 是 → 多语言？
       │   ├─ Go/Java/TS → Temporal
       │   └─ JVM生态 → Cadence
       │
       └─ 否 → AWS Step Functions
```

### 3.2 存储后端选择

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| <10M events/s | PostgreSQL | 成本效益最优 |
| 时序数据 | TimescaleDB | 自动分区优化 |
| >100M events/s | Cassandra | 大规模写入 |

## 四、实施步骤

### 4.1 环境准备

**1. 安装PostgreSQL**

```bash
# Ubuntu/Debian
sudo apt-get install postgresql-15

# macOS
brew install postgresql@15

# 启动服务
sudo systemctl start postgresql
```

**2. 安装Temporal**

```bash
# 使用Docker Compose（推荐）
git clone https://github.com/temporalio/docker-compose.git
cd docker-compose
docker-compose up -d
```

**3. 安装Temporal SDK**

```bash
# Go
go get go.temporal.io/sdk

# Python
pip install temporalio

# TypeScript
npm install @temporalio/client @temporalio/worker @temporalio/workflow
```

### 4.2 配置PostgreSQL

**1. 创建数据库**

```sql
CREATE DATABASE temporal;
CREATE USER temporal WITH PASSWORD 'temporal';
GRANT ALL PRIVILEGES ON DATABASE temporal TO temporal;
```

**2. 优化配置**

```sql
-- 连接池配置
ALTER SYSTEM SET max_connections = 500;
ALTER SYSTEM SET shared_buffers = '8GB';
ALTER SYSTEM SET effective_cache_size = '24GB';

-- 重启PostgreSQL使配置生效
```

**3. 创建索引**

```sql
-- 工作流状态查询索引
CREATE INDEX idx_workflow_status_time ON executions (
    namespace_id,
    workflow_type,
    status,
    start_time DESC
) WHERE status = 'Running';
```

### 4.3 创建第一个Workflow

**Go示例**：

```go
package main

import (
    "go.temporal.io/sdk/workflow"
    "time"
)

func SimpleWorkflow(ctx workflow.Context, name string) (string, error) {
    ao := workflow.ActivityOptions{
        StartToCloseTimeout: time.Minute,
    }
    ctx = workflow.WithActivityOptions(ctx, ao)

    var result string
    err := workflow.ExecuteActivity(ctx, GreetActivity, name).Get(ctx, &result)
    if err != nil {
        return "", err
    }

    return result, nil
}

func GreetActivity(name string) (string, error) {
    return "Hello " + name + "!", nil
}
```

**Python示例**：

```python
from temporalio import workflow, activity
from temporalio.common import RetryPolicy

@activity.defn
async def greet_activity(name: str) -> str:
    return f"Hello {name}!"

@workflow.defn
class SimpleWorkflow:
    @workflow.run
    async def run(self, name: str) -> str:
        return await workflow.execute_activity(
            greet_activity,
            name,
            start_to_close_timeout=timedelta(minutes=1),
            retry_policy=RetryPolicy(maximum_attempts=3)
        )
```

## 五、性能优化建议

### 5.1 连接池配置

```yaml
# temporal.yaml
persistence:
  postgres:
    maxConns: 500
    maxIdleConns: 50
    connMaxLifetime: 1h
    connMaxIdleTime: 10m
```

**计算公式**：

```text
最优连接数 = 平均到达率 × 平均服务时间
```

### 5.2 索引优化

**1. 复合索引**

```sql
CREATE INDEX idx_workflow_status_time ON executions (
    namespace_id,
    workflow_type,
    status,
    start_time DESC
) WHERE status = 'Running';
```

**2. 分区表**

```sql
CREATE TABLE history_events (
    workflow_id uuid,
    event_id bigint,
    event_data jsonb,
    created_at timestamptz
) PARTITION BY RANGE (created_at);

-- 创建月度分区
CREATE TABLE history_events_2025_01 PARTITION OF history_events
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### 5.3 容错配置

**1. 自动重试**

```go
retryPolicy := &temporal.RetryPolicy{
    InitialInterval:    time.Second,
    BackoffCoefficient: 2.0,
    MaximumInterval:    time.Minute,
    MaximumAttempts:    3,
}
```

**2. Saga模式**

```go
func SagaWorkflow(ctx workflow.Context) error {
    // 执行步骤1
    err := workflow.ExecuteActivity(ctx, Step1).Get(ctx, nil)
    if err != nil {
        return err
    }

    // 执行步骤2
    err = workflow.ExecuteActivity(ctx, Step2).Get(ctx, nil)
    if err != nil {
        // 补偿步骤1
        workflow.ExecuteActivity(ctx, CompensateStep1).Get(ctx, nil)
        return err
    }

    return nil
}
```

## 六、监控和调试

### 6.1 Temporal Web UI

访问 `http://localhost:8088` 查看：

- 工作流执行状态
- 活动执行历史
- 性能指标
- 错误日志

### 6.2 性能监控

**关键指标**：

- 吞吐量（workflows/s）
- 延迟（P50, P95, P99）
- 错误率
- 资源使用率

**监控工具**：

- Prometheus + Grafana
- Temporal Web UI
- 自定义监控脚本

### 6.3 日志配置

```go
logger := zap.NewDevelopmentConfig()
logger.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
log, err := logger.Build()
if err != nil {
    log.Fatalln("Unable to create logger", err)
}
```

## 七、常见问题

### 7.1 性能问题

**Q: 吞吐量低于预期？**

A: 检查以下方面：

1. 连接池配置是否合理
2. 索引是否创建
3. 数据库资源是否充足
4. 网络延迟是否过高

**Q: 延迟过高？**

A: 优化建议：

1. 使用复合索引
2. 实施分区表策略
3. 优化Activity执行时间
4. 减少不必要的等待

### 7.2 容错问题

**Q: 工作流执行失败？**

A: 检查：

1. 重试策略配置
2. 超时时间设置
3. Activity幂等性
4. 错误处理逻辑

**Q: 状态恢复失败？**

A: 确保：

1. 事件历史完整
2. 存储后端可用
3. Worker正常运行
4. 版本兼容性

### 7.3 成本问题

**Q: 存储成本过高？**

A: 优化方案：

1. 使用PostgreSQL替代Cassandra（节省90%）
2. 实施数据归档策略
3. 优化索引设计
4. 使用分区表

## 八、下一步

### 8.1 深入学习

1. 阅读[技术堆栈对比分析](../02-technology-comparison/技术堆栈对比分析.md)
2. 研究[企业实践案例](../04-practice-cases/企业实践案例.md)
3. 学习[形式化验证理论](../03-formal-verification/形式化验证理论.md)

### 8.2 实践项目

1. 搭建测试环境
2. 实现示例工作流
3. 执行性能测试
4. 优化配置参数

### 8.3 社区参与

1. 加入Temporal社区
2. 参与讨论和贡献
3. 分享实践经验
4. 收集反馈意见

## 九、参考资源

### 9.1 官方文档

- [Temporal官方文档](https://docs.temporal.io/)
- [PostgreSQL文档](https://www.postgresql.org/docs/)
- [TLA+工具](https://lamport.azurewebsites.net/tla/tla.html)

### 9.2 项目文档

- [综合评估报告](../08-summary/综合评估报告.md)
- [性能基准测试](../06-benchmarks/性能基准测试.md)
- [国际对标分析](../07-international-benchmark/国际对标分析.md)

### 9.3 社区资源

- [Temporal GitHub](https://github.com/temporalio)
- [Temporal Slack](https://temporal.io/slack)
- [Temporal论坛](https://community.temporal.io/)

---

**快速开始指南版本**：1.0

**最后更新**：2024年

**维护者**：项目团队
