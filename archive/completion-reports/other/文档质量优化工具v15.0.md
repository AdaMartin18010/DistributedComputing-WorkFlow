# æ–‡æ¡£è´¨é‡ä¼˜åŒ–å·¥å…·ï¼ˆv15.0ï¼‰

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†æ–‡æ¡£è´¨é‡ä¼˜åŒ–çš„è‡ªåŠ¨åŒ–å·¥å…·å’Œæ£€æŸ¥æ¸…å•ï¼Œç”¨äºæŒç»­ä¼˜åŒ–æ–‡æ¡£è´¨é‡ã€‚

---

## ğŸ”§ è´¨é‡æ£€æŸ¥å·¥å…·

### 1. æœ¯è¯­ä¸€è‡´æ€§æ£€æŸ¥å·¥å…·

**åŠŸèƒ½**ï¼šæ£€æŸ¥æ–‡æ¡£ä¸­æœ¯è¯­ä½¿ç”¨çš„ä¸€è‡´æ€§

**æ£€æŸ¥é¡¹**ï¼š

- æ ¸å¿ƒæœ¯è¯­ä½¿ç”¨æ˜¯å¦ä¸€è‡´
- æœ¯è¯­ç¿»è¯‘æ˜¯å¦ç»Ÿä¸€
- æœ¯è¯­å®šä¹‰æ˜¯å¦å‡†ç¡®

**Pythonå®ç°ç¤ºä¾‹**ï¼š

```python
import re
from typing import Dict, List, Set
from pathlib import Path

class TerminologyChecker:
    """æœ¯è¯­ä¸€è‡´æ€§æ£€æŸ¥å™¨"""

    def __init__(self, terminology_file: str):
        self.terminology = self.load_terminology(terminology_file)
        self.issues: List[Dict] = []

    def load_terminology(self, file_path: str) -> Dict[str, Dict]:
        """åŠ è½½æœ¯è¯­è¡¨"""
        # ä»æœ¯è¯­è¡¨æ–‡ä»¶åŠ è½½æœ¯è¯­å®šä¹‰
        # è¿”å›æ ¼å¼ï¼š{term: {"chinese": "...", "english": "...", "definition": "..."}}
        return {}

    def check_document(self, doc_path: str) -> List[Dict]:
        """æ£€æŸ¥æ–‡æ¡£ä¸­çš„æœ¯è¯­ä½¿ç”¨"""
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()

        issues = []

        # æ£€æŸ¥æ¯ä¸ªæœ¯è¯­
        for term, definition in self.terminology.items():
            # æ£€æŸ¥æœ¯è¯­ä½¿ç”¨æ˜¯å¦ä¸€è‡´
            pattern = re.compile(term, re.IGNORECASE)
            matches = pattern.findall(content)

            if matches:
                # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨æ ‡å‡†å½¢å¼
                standard_form = definition.get("chinese") or definition.get("english")
                for match in matches:
                    if match != standard_form:
                        issues.append({
                            "type": "terminology_inconsistency",
                            "term": term,
                            "found": match,
                            "expected": standard_form,
                            "file": doc_path
                        })

        return issues

    def check_all_documents(self, docs_dir: str) -> Dict[str, List[Dict]]:
        """æ£€æŸ¥æ‰€æœ‰æ–‡æ¡£"""
        results = {}
        docs_path = Path(docs_dir)

        for md_file in docs_path.rglob("*.md"):
            issues = self.check_document(str(md_file))
            if issues:
                results[str(md_file)] = issues

        return results
```

---

### 2. æ ¼å¼ä¸€è‡´æ€§æ£€æŸ¥å·¥å…·

**åŠŸèƒ½**ï¼šæ£€æŸ¥æ–‡æ¡£æ ¼å¼çš„ä¸€è‡´æ€§

**æ£€æŸ¥é¡¹**ï¼š

- æ ‡é¢˜æ ¼å¼æ˜¯å¦ç»Ÿä¸€
- åˆ—è¡¨æ ¼å¼æ˜¯å¦ç»Ÿä¸€
- ä»£ç å—æ ¼å¼æ˜¯å¦ç»Ÿä¸€
- è¡¨æ ¼æ ¼å¼æ˜¯å¦ç»Ÿä¸€

**Pythonå®ç°ç¤ºä¾‹**ï¼š

```python
class FormatChecker:
    """æ ¼å¼ä¸€è‡´æ€§æ£€æŸ¥å™¨"""

    def __init__(self):
        self.issues: List[Dict] = []

    def check_heading_format(self, content: str, file_path: str):
        """æ£€æŸ¥æ ‡é¢˜æ ¼å¼"""
        lines = content.split('\n')

        for i, line in enumerate(lines):
            # æ£€æŸ¥ä¸€çº§æ ‡é¢˜
            if line.startswith('# '):
                if not line[2:].strip():
                    self.issues.append({
                        "type": "empty_heading",
                        "line": i + 1,
                        "file": file_path
                    })

            # æ£€æŸ¥æ ‡é¢˜å±‚çº§
            if line.startswith('#'):
                level = len(line) - len(line.lstrip('#'))
                if level > 6:
                    self.issues.append({
                        "type": "invalid_heading_level",
                        "line": i + 1,
                        "level": level,
                        "file": file_path
                    })

    def check_list_format(self, content: str, file_path: str):
        """æ£€æŸ¥åˆ—è¡¨æ ¼å¼"""
        lines = content.split('\n')

        for i, line in enumerate(lines):
            # æ£€æŸ¥åˆ—è¡¨é¡¹å‰åæ˜¯å¦æœ‰ç©ºè¡Œ
            if line.strip().startswith('- '):
                if i > 0 and lines[i-1].strip() and not lines[i-1].strip().startswith('-'):
                    # åˆ—è¡¨é¡¹å‰åº”è¯¥æœ‰ç©ºè¡Œ
                    if lines[i-1].strip():
                        self.issues.append({
                            "type": "missing_blank_line_before_list",
                            "line": i + 1,
                            "file": file_path
                        })

    def check_code_block_format(self, content: str, file_path: str):
        """æ£€æŸ¥ä»£ç å—æ ¼å¼"""
        # æ£€æŸ¥ä»£ç å—æ˜¯å¦æœ‰è¯­è¨€æ ‡è¯†
        pattern = re.compile(r'```(\w+)?\n')
        matches = pattern.findall(content)

        for match in matches:
            if not match:
                self.issues.append({
                    "type": "missing_code_language",
                    "file": file_path
                })

    def check_all(self, doc_path: str):
        """æ£€æŸ¥æ‰€æœ‰æ ¼å¼é—®é¢˜"""
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()

        self.check_heading_format(content, doc_path)
        self.check_list_format(content, doc_path)
        self.check_code_block_format(content, doc_path)

        return self.issues
```

---

### 3. é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥å·¥å…·

**åŠŸèƒ½**ï¼šæ£€æŸ¥æ–‡æ¡£ä¸­é“¾æ¥çš„æœ‰æ•ˆæ€§

**æ£€æŸ¥é¡¹**ï¼š

- å†…éƒ¨é“¾æ¥æ˜¯å¦æœ‰æ•ˆ
- å¤–éƒ¨é“¾æ¥æ˜¯å¦å¯è®¿é—®
- é”šç‚¹é“¾æ¥æ˜¯å¦æ­£ç¡®

**Pythonå®ç°ç¤ºä¾‹**ï¼š

```python
import requests
from pathlib import Path

class LinkChecker:
    """é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥å™¨"""

    def __init__(self, base_dir: str):
        self.base_dir = Path(base_dir)
        self.issues: List[Dict] = []

    def check_internal_link(self, link: str, current_file: str) -> bool:
        """æ£€æŸ¥å†…éƒ¨é“¾æ¥"""
        # è§£æç›¸å¯¹è·¯å¾„
        if link.startswith('../'):
            # ç›¸å¯¹è·¯å¾„
            current_path = Path(current_file).parent
            target_path = current_path / link
        elif link.startswith('./'):
            # å½“å‰ç›®å½•
            current_path = Path(current_file).parent
            target_path = current_path / link[2:]
        else:
            # ç»å¯¹è·¯å¾„ï¼ˆç›¸å¯¹äºbase_dirï¼‰
            target_path = self.base_dir / link

        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not target_path.exists():
            self.issues.append({
                "type": "broken_internal_link",
                "link": link,
                "file": current_file,
                "target": str(target_path)
            })
            return False

        return True

    def check_anchor_link(self, link: str, current_file: str) -> bool:
        """æ£€æŸ¥é”šç‚¹é“¾æ¥"""
        if '#' not in link:
            return True

        file_part, anchor = link.split('#', 1)

        # æ£€æŸ¥æ–‡ä»¶éƒ¨åˆ†
        if file_part:
            if not self.check_internal_link(file_part, current_file):
                return False

        # æ£€æŸ¥é”šç‚¹ï¼ˆéœ€è¦è¯»å–ç›®æ ‡æ–‡ä»¶ï¼‰
        target_file = self.base_dir / file_part if file_part else Path(current_file)
        if target_file.exists():
            with open(target_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # æ£€æŸ¥é”šç‚¹æ˜¯å¦å­˜åœ¨
            anchor_pattern = anchor.lower().replace(' ', '-')
            if anchor_pattern not in content.lower():
                self.issues.append({
                    "type": "broken_anchor_link",
                    "link": link,
                    "file": current_file,
                    "anchor": anchor
                })
                return False

        return True

    def check_external_link(self, url: str) -> bool:
        """æ£€æŸ¥å¤–éƒ¨é“¾æ¥"""
        try:
            response = requests.head(url, timeout=5, allow_redirects=True)
            if response.status_code >= 400:
                return False
            return True
        except:
            return False

    def check_document(self, doc_path: str):
        """æ£€æŸ¥æ–‡æ¡£ä¸­çš„æ‰€æœ‰é“¾æ¥"""
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # æŸ¥æ‰¾æ‰€æœ‰é“¾æ¥
        link_pattern = re.compile(r'\[([^\]]+)\]\(([^\)]+)\)')
        matches = link_pattern.findall(content)

        for text, link in matches:
            if link.startswith('http://') or link.startswith('https://'):
                # å¤–éƒ¨é“¾æ¥
                if not self.check_external_link(link):
                    self.issues.append({
                        "type": "broken_external_link",
                        "link": link,
                        "file": doc_path
                    })
            elif link.startswith('#') or '#' in link:
                # é”šç‚¹é“¾æ¥
                self.check_anchor_link(link, doc_path)
            else:
                # å†…éƒ¨é“¾æ¥
                self.check_internal_link(link, doc_path)

        return self.issues
```

---

### 4. å†…å®¹å‡†ç¡®æ€§éªŒè¯å·¥å…·

**åŠŸèƒ½**ï¼šéªŒè¯æ–‡æ¡£å†…å®¹çš„å‡†ç¡®æ€§

**æ£€æŸ¥é¡¹**ï¼š

- æŠ€æœ¯ç»†èŠ‚æ˜¯å¦å‡†ç¡®
- å…¬å¼æ˜¯å¦æ­£ç¡®
- æ•°æ®æ˜¯å¦åˆç†

**Pythonå®ç°ç¤ºä¾‹**ï¼š

```python
class ContentAccuracyChecker:
    """å†…å®¹å‡†ç¡®æ€§éªŒè¯å™¨"""

    def __init__(self):
        self.issues: List[Dict] = []

    def check_formula_format(self, content: str, file_path: str):
        """æ£€æŸ¥å…¬å¼æ ¼å¼"""
        # æ£€æŸ¥LaTeXå…¬å¼æ ¼å¼
        formula_pattern = re.compile(r'\$\$.*?\$\$', re.DOTALL)
        formulas = formula_pattern.findall(content)

        for formula in formulas:
            # æ£€æŸ¥å…¬å¼æ˜¯å¦å®Œæ•´
            if formula.count('$') != 4:
                self.issues.append({
                    "type": "malformed_formula",
                    "formula": formula[:50],
                    "file": file_path
                })

    def check_data_consistency(self, content: str, file_path: str):
        """æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§"""
        # æ£€æŸ¥æ€§èƒ½æ•°æ®æ˜¯å¦åˆç†
        # ä¾‹å¦‚ï¼šååé‡åº”è¯¥å¤§äº0ï¼Œå»¶è¿Ÿåº”è¯¥å¤§äº0ç­‰
        pass

    def check_reference_format(self, content: str, file_path: str):
        """æ£€æŸ¥å¼•ç”¨æ ¼å¼"""
        # æ£€æŸ¥å‚è€ƒæ–‡çŒ®æ ¼å¼
        ref_pattern = re.compile(r'\[(\d+)\]')
        refs = ref_pattern.findall(content)

        # æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„å‚è€ƒæ–‡çŒ®åˆ—è¡¨
        if refs and '## å‚è€ƒæ–‡çŒ®' not in content and '## åã€å‚è€ƒæ–‡çŒ®' not in content:
            self.issues.append({
                "type": "missing_references_section",
                "file": file_path
            })

    def check_all(self, doc_path: str):
        """æ£€æŸ¥æ‰€æœ‰å†…å®¹å‡†ç¡®æ€§é—®é¢˜"""
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()

        self.check_formula_format(content, doc_path)
        self.check_data_consistency(content, doc_path)
        self.check_reference_format(content, doc_path)

        return self.issues
```

---

## ğŸ“Š è´¨é‡æ£€æŸ¥æŠ¥å‘Šç”Ÿæˆ

### ç»¼åˆè´¨é‡æ£€æŸ¥æŠ¥å‘Š

**åŠŸèƒ½**ï¼šç”Ÿæˆç»¼åˆè´¨é‡æ£€æŸ¥æŠ¥å‘Š

**Pythonå®ç°ç¤ºä¾‹**ï¼š

```python
class QualityReportGenerator:
    """è´¨é‡æŠ¥å‘Šç”Ÿæˆå™¨"""

    def __init__(self, docs_dir: str):
        self.docs_dir = docs_dir
        self.terminology_checker = TerminologyChecker("æœ¯è¯­è¡¨.md")
        self.format_checker = FormatChecker()
        self.link_checker = LinkChecker(docs_dir)
        self.content_checker = ContentAccuracyChecker()

    def generate_report(self) -> Dict:
        """ç”Ÿæˆè´¨é‡æ£€æŸ¥æŠ¥å‘Š"""
        report = {
            "summary": {
                "total_documents": 0,
                "total_issues": 0,
                "issues_by_type": {}
            },
            "details": {}
        }

        docs_path = Path(self.docs_dir)

        for md_file in docs_path.rglob("*.md"):
            if md_file.name.startswith('.'):
                continue

            doc_path = str(md_file)
            report["summary"]["total_documents"] += 1

            # æ‰§è¡Œå„é¡¹æ£€æŸ¥
            terminology_issues = self.terminology_checker.check_document(doc_path)
            format_issues = self.format_checker.check_all(doc_path)
            link_issues = self.link_checker.check_document(doc_path)
            content_issues = self.content_checker.check_all(doc_path)

            all_issues = terminology_issues + format_issues + link_issues + content_issues

            if all_issues:
                report["details"][doc_path] = {
                    "terminology_issues": len(terminology_issues),
                    "format_issues": len(format_issues),
                    "link_issues": len(link_issues),
                    "content_issues": len(content_issues),
                    "total_issues": len(all_issues),
                    "issues": all_issues
                }

                report["summary"]["total_issues"] += len(all_issues)

                # ç»Ÿè®¡é—®é¢˜ç±»å‹
                for issue in all_issues:
                    issue_type = issue.get("type", "unknown")
                    report["summary"]["issues_by_type"][issue_type] = \
                        report["summary"]["issues_by_type"].get(issue_type, 0) + 1

        return report

    def export_report(self, output_file: str):
        """å¯¼å‡ºæŠ¥å‘Š"""
        report = self.generate_report()

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# æ–‡æ¡£è´¨é‡æ£€æŸ¥æŠ¥å‘Š\n\n")
            f.write(f"**æ£€æŸ¥æ—¶é—´**ï¼š{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"**æ£€æŸ¥æ–‡æ¡£æ•°**ï¼š{report['summary']['total_documents']}\n\n")
            f.write(f"**å‘ç°é—®é¢˜æ•°**ï¼š{report['summary']['total_issues']}\n\n")

            f.write("## é—®é¢˜ç±»å‹ç»Ÿè®¡\n\n")
            for issue_type, count in report['summary']['issues_by_type'].items():
                f.write(f"- {issue_type}: {count}\n")

            f.write("\n## è¯¦ç»†é—®é¢˜åˆ—è¡¨\n\n")
            for doc_path, details in report['details'].items():
                f.write(f"### {doc_path}\n\n")
                f.write(f"- æ€»é—®é¢˜æ•°ï¼š{details['total_issues']}\n")
                f.write(f"- æœ¯è¯­é—®é¢˜ï¼š{details['terminology_issues']}\n")
                f.write(f"- æ ¼å¼é—®é¢˜ï¼š{details['format_issues']}\n")
                f.write(f"- é“¾æ¥é—®é¢˜ï¼š{details['link_issues']}\n")
                f.write(f"- å†…å®¹é—®é¢˜ï¼š{details['content_issues']}\n\n")

                for issue in details['issues']:
                    f.write(f"  - [{issue['type']}] {issue.get('message', '')}\n")
                f.write("\n")
```

---

## ğŸ” ä½¿ç”¨è¯´æ˜

### 1. è¿è¡Œè´¨é‡æ£€æŸ¥

```bash
# å®‰è£…ä¾èµ–
pip install requests

# è¿è¡Œè´¨é‡æ£€æŸ¥
python quality_checker.py --docs-dir ./docs --output report.md
```

### 2. ä¿®å¤é—®é¢˜

æ ¹æ®æŠ¥å‘Šä¸­çš„é—®é¢˜åˆ—è¡¨ï¼Œé€ä¸€ä¿®å¤ï¼š

- æœ¯è¯­ä¸ä¸€è‡´ï¼šç»Ÿä¸€æœ¯è¯­ä½¿ç”¨
- æ ¼å¼é—®é¢˜ï¼šä¿®å¤æ ¼å¼é”™è¯¯
- é“¾æ¥é—®é¢˜ï¼šä¿®å¤æ— æ•ˆé“¾æ¥
- å†…å®¹é—®é¢˜ï¼šä¿®æ­£é”™è¯¯å†…å®¹

### 3. æŒç»­ä¼˜åŒ–

- å®šæœŸè¿è¡Œè´¨é‡æ£€æŸ¥
- åŠæ—¶ä¿®å¤å‘ç°çš„é—®é¢˜
- æ›´æ–°è´¨é‡æ£€æŸ¥è§„åˆ™

---

## ğŸ“‹ è´¨é‡æ£€æŸ¥æ¸…å•

### æœ¯è¯­ä¸€è‡´æ€§æ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰æ ¸å¿ƒæœ¯è¯­ä½¿ç”¨ä¸€è‡´
- [ ] æœ¯è¯­ç¿»è¯‘ç»Ÿä¸€
- [ ] æœ¯è¯­å®šä¹‰å‡†ç¡®
- [ ] é¦–æ¬¡å‡ºç°æ—¶åŒ…å«å®Œæ•´å½¢å¼

### æ ¼å¼ä¸€è‡´æ€§æ£€æŸ¥æ¸…å•

- [ ] æ ‡é¢˜æ ¼å¼ç»Ÿä¸€
- [ ] åˆ—è¡¨æ ¼å¼ç»Ÿä¸€
- [ ] ä»£ç å—æ ¼å¼ç»Ÿä¸€
- [ ] è¡¨æ ¼æ ¼å¼ç»Ÿä¸€
- [ ] å¼•ç”¨æ ¼å¼ç»Ÿä¸€

### é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰å†…éƒ¨é“¾æ¥æœ‰æ•ˆ
- [ ] æ‰€æœ‰å¤–éƒ¨é“¾æ¥å¯è®¿é—®
- [ ] æ‰€æœ‰é”šç‚¹é“¾æ¥æ­£ç¡®

### å†…å®¹å‡†ç¡®æ€§æ£€æŸ¥æ¸…å•

- [ ] æŠ€æœ¯ç»†èŠ‚å‡†ç¡®
- [ ] å…¬å¼æ­£ç¡®
- [ ] æ•°æ®åˆç†
- [ ] å¼•ç”¨å‡†ç¡®

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv15.0

**åˆ›å»ºæ—¶é—´**ï¼š2024å¹´

**ç»´æŠ¤è€…**ï¼šé¡¹ç›®å›¢é˜Ÿ
