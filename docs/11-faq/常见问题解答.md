# 常见问题解答 (FAQ)

## 一、技术选型问题

### Q1: 为什么选择Temporal而不是Airflow？

**A**: Temporal和Airflow适用于不同场景：

| 维度 | Temporal | Airflow |
|------|----------|---------|
| **适用场景** | 长周期业务流程 | 数据管道 |
| **编程模型** | Workflow-as-Code | DAG-as-Code |
| **循环支持** | ✅ 原生支持 | ❌ 不支持 |
| **状态恢复** | ✅ 自动恢复 | ❌ 手动重跑 |
| **启动延迟** | <100ms | 2-5秒 |
| **吞吐量** | 847 tasks/s | 10 tasks/s |

**推荐**：

- 微服务编排、长周期业务流程 → Temporal
- 数据管道、ETL任务 → Airflow

### Q2: PostgreSQL和Cassandra如何选择？

**A**: 选择标准：

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| <10M events/s | PostgreSQL | 成本节省90%，性能提升5.4倍 |
| 时序数据 | TimescaleDB | 自动分区优化 |
| >100M events/s | Cassandra | 大规模写入能力 |

**详细对比**：

- **成本**：PostgreSQL节省90%（$3,325 vs $33,251/月）
- **性能**：PostgreSQL写入快5.4倍，查询快10-47倍
- **运维**：PostgreSQL运维复杂度更低

### Q3: Temporal支持哪些编程语言？

**A**: Temporal支持多种编程语言：

| 语言 | SDK状态 | 推荐度 |
|------|--------|--------|
| **Go** | ✅ 生产就绪 | ⭐⭐⭐⭐⭐ |
| **Java** | ✅ 生产就绪 | ⭐⭐⭐⭐⭐ |
| **TypeScript** | ✅ 生产就绪 | ⭐⭐⭐⭐⭐ |
| **Python** | ✅ 生产就绪 | ⭐⭐⭐⭐ |
| **PHP** | ✅ 生产就绪 | ⭐⭐⭐ |
| **C#** | ✅ 生产就绪 | ⭐⭐⭐ |
| **Ruby** | ⚠️ 实验性 | ⭐⭐ |

## 二、性能问题

### Q4: 如何提高工作流吞吐量？

**A**: 优化建议：

1. **连接池配置**

   ```yaml
   persistence:
     postgres:
       maxConns: 500  # 根据并发量调整
       maxIdleConns: 50
   ```

2. **并行执行**

   ```go
   // 并行执行多个Activity
   future1 := workflow.ExecuteActivity(ctx, ProcessA)
   future2 := workflow.ExecuteActivity(ctx, ProcessB)
   future3 := workflow.ExecuteActivity(ctx, ProcessC)
   ```

3. **批量处理**

   ```go
   // 批量处理减少数据库操作
   workflow.ExecuteActivity(ctx, ProcessBatch, items)
   ```

4. **索引优化**

   ```sql
   CREATE INDEX idx_workflow_status_time ON executions(
       namespace_id, workflow_type, status, start_time DESC
   ) WHERE status = 'Running';
   ```

### Q5: 延迟过高怎么办？

**A**: 排查和优化步骤：

1. **检查数据库性能**

   ```sql
   -- 分析慢查询
   SELECT * FROM pg_stat_statements
   ORDER BY mean_exec_time DESC LIMIT 10;
   ```

2. **优化索引**
   - 创建复合索引
   - 使用覆盖索引
   - 实施分区表

3. **减少等待时间**
   - 优化Activity执行时间
   - 使用并行执行
   - 减少不必要的等待

4. **网络优化**
   - 使用本地数据库
   - 优化网络配置
   - 使用连接池

### Q6: 如何优化存储成本？

**A**: 成本优化策略：

1. **使用PostgreSQL替代Cassandra**
   - 节省90%成本（$3,325 vs $33,251/月）

2. **数据归档**

   ```sql
   -- 归档90天前的数据
   INSERT INTO history_events_archive
   SELECT * FROM history_events
   WHERE created_at < NOW() - INTERVAL '90 days';
   ```

3. **索引优化**
   - 删除不必要的索引
   - 使用部分索引
   - 定期重建索引

4. **分区表**
   - 按时间分区
   - 自动删除旧分区
   - 减少存储空间

## 三、容错和可靠性问题

### Q7: 如何确保Activity的幂等性？

**A**: 幂等性实现方法：

1. **使用幂等键**

   ```go
   func ProcessPayment(ctx context.Context, payment Payment) error {
       idempotencyKey := fmt.Sprintf("payment-%s-%d",
           payment.OrderID, payment.Amount)

       // 检查是否已处理
       if exists, _ := checkIfProcessed(idempotencyKey); exists {
           return nil
       }

       // 处理支付
       result := executePayment(payment)

       // 记录处理结果
       recordProcessing(idempotencyKey, result)
       return nil
   }
   ```

2. **数据库唯一约束**

   ```sql
   CREATE UNIQUE INDEX idx_idempotency_key
   ON payments(idempotency_key);
   ```

3. **使用Temporal的Activity ID**

   ```go
   activityID := activity.GetInfo(ctx).ActivityID
   // 使用activityID作为幂等键
   ```

### Q8: 如何处理分布式事务？

**A**: 使用Saga模式：

```go
func SagaWorkflow(ctx workflow.Context, order Order) error {
    // 步骤1：锁定库存
    err := workflow.ExecuteActivity(ctx, LockInventory, order).Get(ctx, nil)
    if err != nil {
        return err
    }

    // 步骤2：处理支付
    err = workflow.ExecuteActivity(ctx, ProcessPayment, order).Get(ctx, nil)
    if err != nil {
        // 补偿：解锁库存
        workflow.ExecuteActivity(ctx, UnlockInventory, order).Get(ctx, nil)
        return err
    }

    // 步骤3：发货
    err = workflow.ExecuteActivity(ctx, ShipOrder, order).Get(ctx, nil)
    if err != nil {
        // 补偿：退款和解锁库存
        workflow.ExecuteActivity(ctx, RefundPayment, order).Get(ctx, nil)
        workflow.ExecuteActivity(ctx, UnlockInventory, order).Get(ctx, nil)
        return err
    }

    return nil
}
```

### Q9: 工作流执行失败后如何恢复？

**A**: Temporal自动恢复机制：

1. **自动重试**

   ```go
   retryPolicy := &temporal.RetryPolicy{
       InitialInterval:    time.Second,
       BackoffCoefficient: 2.0,
       MaximumInterval:    time.Minute,
       MaximumAttempts:    3,
   }
   ```

2. **状态持久化**
   - Temporal自动持久化工作流状态
   - Worker重启后自动恢复
   - 无需手动干预

3. **手动恢复**

   ```go
   // 使用相同workflowID重新启动
   client.ExecuteWorkflow(ctx, options, Workflow, input)
   ```

## 四、配置和部署问题

### Q10: 如何配置PostgreSQL连接池？

**A**: 推荐配置：

```yaml
persistence:
  postgres:
    maxConns: 500          # 最大连接数
    maxIdleConns: 50       # 最大空闲连接数
    connMaxLifetime: 1h    # 连接最大生存时间
    connMaxIdleTime: 10m   # 空闲连接超时时间
```

**计算公式**：

```text
最优连接数 = 平均到达率 × 平均服务时间
```

### Q11: 如何部署Temporal集群？

**A**: 部署步骤：

1. **使用Docker Compose（开发环境）**

   ```bash
   git clone https://github.com/temporalio/docker-compose.git
   cd docker-compose
   docker-compose up -d
   ```

2. **使用Kubernetes（生产环境）**

   ```bash
   helm repo add temporal https://temporalio.github.io/helm-charts
   helm install temporal temporal/temporal
   ```

3. **配置存储后端**

   ```yaml
   persistence:
     defaultStore: postgres
     visibilityStore: postgres
     postgres:
       host: postgres.example.com
       port: 5432
       database: temporal
   ```

### Q12: 如何监控Temporal集群？

**A**: 监控方案：

1. **Temporal Web UI**
   - 访问 `http://localhost:8088`
   - 查看工作流状态
   - 查看性能指标

2. **Prometheus + Grafana**

   ```yaml
   metrics:
     prometheus:
       listenAddress: "0.0.0.0:9090"
   ```

3. **自定义监控**
   - 监控关键指标
   - 设置告警规则
   - 定期检查日志

## 五、开发和调试问题

### Q13: 如何调试工作流？

**A**: 调试方法：

1. **使用Temporal Web UI**
   - 查看工作流执行历史
   - 查看Activity执行详情
   - 查看错误信息

2. **日志记录**

   ```go
   logger := workflow.GetLogger(ctx)
   logger.Info("Workflow started", "input", input)
   ```

3. **测试环境**

   ```go
   testSuite := &tests.WorkflowTestSuite{}
   env := testSuite.NewTestWorkflowEnvironment()
   env.ExecuteWorkflow(Workflow, input)
   ```

### Q14: 如何测试工作流？

**A**: 测试方法：

1. **单元测试**

   ```go
   func TestWorkflow(t *testing.T) {
       testSuite := &tests.WorkflowTestSuite{}
       env := testSuite.NewTestWorkflowEnvironment()

       env.OnActivity(ProcessPayment, mock.Anything).
           Return(nil)

       env.ExecuteWorkflow(OrderWorkflow, Order{})
       require.True(t, env.IsWorkflowCompleted())
   }
   ```

2. **集成测试**
   - 使用测试环境
   - 启动真实服务
   - 验证端到端流程

### Q15: 如何升级工作流版本？

**A**: 版本升级策略：

1. **使用版本标记**

   ```go
   version := workflow.GetVersion(ctx, "workflow-version",
       workflow.DefaultVersion, 2)
   ```

2. **向后兼容**
   - 新版本必须兼容旧版本
   - 逐步迁移
   - 监控迁移进度

3. **平滑升级**
   - 先部署新版本Worker
   - 等待旧工作流完成
   - 逐步切换到新版本

## 六、其他问题

### Q16: Temporal的许可证是什么？

**A**: Temporal使用MIT许可证，可以自由使用、修改和分发。

### Q17: Temporal支持哪些云平台？

**A**: Temporal支持所有主要云平台：

- AWS
- Google Cloud Platform
- Microsoft Azure
- 自托管

### Q18: 如何获取帮助？

**A**: 获取帮助的渠道：

1. **官方文档**：<https://docs.temporal.io/>
2. **GitHub Issues**：<https://github.com/temporalio/temporal/issues>
3. **Slack社区**：<https://temporal.io/slack>
4. **论坛**：<https://community.temporal.io/>

### Q19: 项目文档在哪里？

**A**: 项目文档位置：

- [综合评估报告](../08-summary/综合评估报告.md)
- [技术堆栈对比](../02-technology-comparison/技术堆栈对比分析.md)
- [企业实践案例](../04-practice-cases/企业实践案例.md)
- [性能基准测试](../06-benchmarks/性能基准测试.md)
- [快速开始指南](../09-quickstart/快速开始指南.md)
- [最佳实践指南](../10-best-practices/最佳实践指南.md)

### Q20: 如何贡献项目？

**A**: 贡献方式：

1. **报告问题**：提交GitHub Issue
2. **提交代码**：创建Pull Request
3. **改进文档**：更新文档内容
4. **分享经验**：在社区分享实践

---

**FAQ版本**：1.0

**最后更新**：2024年

**维护者**：项目团队
